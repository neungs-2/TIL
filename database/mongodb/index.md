# **Index**

### **커버드 쿼리**

- 쿼리 결과를 얻어내는데 실제 도큐먼트의 데이터를 사용하지 않고 인덱스만으로 커버가 가능한 쿼리
- 실무에서는 커버드 쿼리 쓰는 것 유리
- Id 필드를 반환 받지 않도록 반환 받을 키를 지정
- 쿼리하지 않는 필드에 인덱스를 만들어야 할 수도 있으므로 쓰기 작업 시 늘어날 부하와 쿼리 속도 조율
- Explain 시 IXSCAN 단계가 존재, totalDocsExamined 는 0이 됨

### **암시적 인덱스**

- 복합 인덱스의 앞부분은 ‘공짜 인덱스’가 됨 => index prefix
- 예시) 복합 인덱스: {‘a’ : 1, ‘b’ : 1, ‘c’ : 1, ‘d’ : 1}
  - 복합 인덱스는 다음과 같은 인덱스로도 적용 가능
  - {‘a’ : 1} , {‘a’ : 1, ‘b’ : 1}, {‘a’ : 1, ‘b’ : 1, ‘c’ : 1}

### **비효율적인 연산자**

- $ne 연산자 : 지정된 항목 제외한 모든 인덱스 항목을 살펴봐야 함
  - 예시) {‘$ne’ : 3}이면 3보다 작은 항목과 3보다 큰 항목을 모두 조사
- 3이 컬렉션에서 큰 부분 차지 시에는 효율적이지만 아니라면 비효율적
  - $not, $nin

### **범위**

- 다중 필드로 인덱스 설계 시
  - 완전 일치가 사용될 필드를 앞에 ({‘x’ : 1})
  - 범위 안에서 검색할 필드를 뒤에 (‘y’ : {‘gt’ : 3, ‘lt’ : 5})

### **OR 쿼리**

- 몽고 DB는 쿼리 당 하나의 인덱스만 사용 가능
- 유일한 예외는 ‘$or’
  - 예시) index: {‘x’: 1}, {‘y’:1}, query: {‘x’: 123, ‘y’:456}
  - 일반적인 쿼리의 경우 두 개의 인덱스 중 하나만 사용
- $or 은 두개의 쿼리 수행 후 중복을 제거하여 결과를 합침 (절마다 하나씩 인덱스를 사용 가능)
- 여러 번 쿼리 후 병합 시 비효율적이므로 $or 보다 가급적이면 $in을 사용할 것

### **서브 도큐먼트 (내장 도큐먼트) 인덱싱**

- 서브 도큐먼트의 필드를 인덱싱 하는 것과 내장 도큐먼트 자체를 인덱싱 하는 것은 작동 방식에 차이 존재
- 서브 도큐먼트의 필드 인덱싱
  - 해당 필드를 사용하는 쿼리 시 도움
- 서브 도큐먼트 자체를 인덱싱
  - 서브 도큐먼트 전체 쿼리 시에만 도움
- 예시) 도큐먼트: user: {‘username’ : “name”, “loc” : {“ip”: “0.0.0.0”, “city” : “Seoul”, “state” : “NY”}}
  - 인덱스: {“loc.city” : 1} 경우 loc.city 사용 쿼리에 사용
  - 인덱스: {“loc” : 1} 경우 도큐먼트 전체가 올바른 필드 순서로 기술된 쿼리에만 인덱스 사용

### **배열 인덱싱**

- 배열을 인덱싱하면 배열의 각 요소에 인덱스 항목을 생성
- 입력/갱신/제거 작업 시 모든 배열 요소가 갱신되어야 하므로 부담
- 배열의 특정 항목에 인덱스 생성 가능
  - ex) db.blog.createIndex({“comments.10.votes” : 1}). => 11번째 요소 찾을 때만 사용 (인덱스 시작: 0)
- 배열 전체를 단일 개체처럼 인덱싱 불가
- 배열 요소 인덱싱에는 위치 개념이 없어서 comment.4 처럼 특정 배열 요소 찾는 쿼리에 적용 불가
- 인덱스 항목의 한 필드만 배열로부터 가져올 수 있음
  - 다중 키 인덱스(Multi key Index)에 의해 n\*m개 인덱스가 생기는 것을 방지
  - 배열 필드를 인덱스 키로 가지면 인덱스는 즉시 다중키 인덱스로 표시 (explain에서 ‘isMultiKey’ 표현)
  - 다중키로 표현되면 도큐먼트가 모두 제거되어도 비다중키가 될 수 없음
    - 인덱스를 삭제 후 재생성 해야만 가능
    - 다중키는 비 다중키보다 약간 느림

인덱스 카디널리티
카디널리티 : 컬렉션의 한 필드에 대해 고윳값이 얼마나 많은지 나타냄
성별같은 필드는 값이 2개 뿐이며 매우 낮은 카디널리티
이름, 이메일주소 등은 높은 카디널리티
카디널리티가 높을 수록 인덱싱에 도움이 되는 필드
복합 인덱스에서 카디널리티가 높은 키를 앞에 두는 것이 유리함

인덱스를 생성하지 않는 경우
인덱스는 데이터의 일부를 조회할 때 가장 효율적, 컬렉션에서 가져와야 하는 부분이 많을수록 비효율적
인덱스를 하나 사용하기 위해 두번의 조회가 필요
인덱스 항목 스캔, 인덱스 포인터가 가리키는 도큐먼트 스캔
따라서 인덱스가 없는게 더 빠른 쿼리도 존재 - 인덱스 사용보다 컬렉션 스캔이 적합한 경우 존재

인덱스가 적합 컬렉션 스캔이 적합
큰 컬렉션 작은 컬렉션
큰 도큐먼트 작은 도큐먼트
선택적 쿼리 비선택적 쿼리

*선택 쿼리: 단순히 데이터 검색만을 수행
*실행 쿼리: 테이블의 내용을 변경하는 쿼리

## 인덱스 종류

고유 인덱스 (Unique Index)
각 값이 인덱스에 한 번 이하 나타나도록 보장
특정 필드가 unique해야 한다는 제약조건 걸 때 사용
기존 컬렉션에 고유 인덱스 구축 시 중복값 있으면 실패
`db.collection.createIndex({username: 1}, {unique: true})`

복합 고유 인덱스
개별 키는 같은 값을 가질 수 있음
인덱스 항목의 모든 키에 걸친 값의 조합은 unique
MongoDB에서 큰 파일을 저장하는 표준 방식

부분 인덱스
개별 키는 같은 값을 가질 수 있음 œ
