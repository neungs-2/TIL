# Call Stack and Memory Heap Structure

- 자바스크립트 엔진은 **Call Stack**과 **Memory Heap**으로 구성
- JS는 **Single thread** 방식의 언어
  - **Call Stack**이 1개 라는 뜻

<br>

## **Call Stack**

- 원시 타입 데이터가 저장
- 실행 콘텍스트(Execution Context)를 통해 다수의 작업
  - 변수 식별자 저장
  - 스코프 체인 및 this 관리
  - 코드 실행 순서 관리 등을 수행

---

<br>

## **Memory Heap**

- 참조 타입(객체) 데이터가 저장
- 메모리 할당이 일어남
- 데이터 수정 시 데이터가 커질 수 있음

---

<br>

## **데이터 저장 구조**

![image](https://user-images.githubusercontent.com/60606025/148631917-42417e9b-c649-430d-aa6f-386aed473a9d.png)

<br>

**_원시 타입 데이터_**

- **원시 타입 데이터**는 **콜 스택**에 저장
- 변수 식별자에는 값이 저장된 콜 스택 메모리의 주소값이 저장
- 식별자는 콜스택 상의 **실행 컨텍스트의 렉시컬 환경**에 저장

<br>

**_참조 타입 데이터_**

- **참조 타입**은 **메모리 힙**에 저장
- 참조 타입 데이터가 저장된 **메모리 힙의 주소값**은 **콜스택**에 각각 저장
- 식별자에는 메모리 힙의 주소값이 저장된 콜 스택 주소가 저장
- 식별자는 콜스택 상의 **실행 컨텍스트의 렉시컬 환경**에 저장

---

<br>

## **데이터 변경 시 구조**

**_원시 타입 데이터_**

```js
//변수 선언 및 할당
let a = 10;
let b = 20;

// 타입 재할당 Case 1
a = 20;

// 타입 재할당 Case 2
b = 30;
```

- **Case 1**
  - 원시 타입 값을 바꾸면 메모리 값을 변경하는 것이 아닌 메모리 재할당
  - 이 때 기존 값이 있다면 이미 있는 값의 메모리 주소로 교체
  - 따라서 a와 b가 가리키는 주소값이 동일해짐
    <br>
    ![image](https://user-images.githubusercontent.com/60606025/148633918-49a0c39a-70c6-4d55-816d-9c2b0bc54d85.png)

<br>

- **Case 2**
  - 원시 타입은 값을 변경하는 것이 아닌 메모리 재할당
  - b는 30을 할당한 새로운 메모리 주소를 가리킴
    <br>
    ![image](https://user-images.githubusercontent.com/60606025/148633948-8dd18a03-efa3-4caa-bf77-da486efcf0ae.png)

<br>

- 값 10이 저장된 메모리는 참조하고 있는 식별자가 없음
- 가비지 컬렉터에 의해 메모리에서 해제됨

<br>

**_참조 타입 데이터_**

- 참조 타입 값은 콜스택에서 힙 영역의 주소값 지님
- 힙 영역은 데이터의 크기가 커져도 됨
- 메모리 재할당이 아닌 데이터의 수정
  - 단, `arr.push(value);`는 값의 수정
  - `arr = [value];`는 재할당
  - `obj[key] = value;` 동적 할당은 값의 수정
  - `obj = {key: value};`는 재할당

<br>

**_let과 const_**

- let: 재할당 가능, const: 재할당 금지
- 여기서 재할당은 메모리 주소의 변경
- 참조 타입 값은 데이터 변경 시 재할당이 아닌 값의 수정
- 따라서 참조 타입은 식별자 키워드에 const 사용해도 값 수정 가능
- const 사용시 아래의 경우는 불가능
  - 메모리 주소를 바꿔야 하는 경우 불가능

```js
const ref = [];
ref.push(1); // 가능
ref = [2]; // 불가능
ref = 3; // 불가능
```
