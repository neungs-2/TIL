# **Index**

### **커버드 쿼리**

- 쿼리 결과를 얻어내는데 실제 도큐먼트의 데이터를 사용하지 않고 인덱스만으로 커버가 가능한 쿼리
- 실무에서는 커버드 쿼리 쓰는 것 유리
- Id 필드를 반환 받지 않도록 반환 받을 키를 지정
- 쿼리하지 않는 필드에 인덱스를 만들어야 할 수도 있으므로 쓰기 작업 시 늘어날 부하와 쿼리 속도 조율
- Explain 시 IXSCAN 단계가 존재, totalDocsExamined 는 0이 됨

<br>

### **암시적 인덱스**

- 복합 인덱스의 앞부분은 ‘공짜 인덱스’가 됨 => index prefix
- 예시) 복합 인덱스: {‘a’ : 1, ‘b’ : 1, ‘c’ : 1, ‘d’ : 1}
  - 복합 인덱스는 다음과 같은 인덱스로도 적용 가능
  - {‘a’ : 1} , {‘a’ : 1, ‘b’ : 1}, {‘a’ : 1, ‘b’ : 1, ‘c’ : 1}

<br>

### **비효율적인 연산자**

- $ne 연산자 : 지정된 항목 제외한 모든 인덱스 항목을 살펴봐야 함
  - 예시) {‘$ne’ : 3}이면 3보다 작은 항목과 3보다 큰 항목을 모두 조사
- 3이 컬렉션에서 큰 부분 차지 시에는 효율적이지만 아니라면 비효율적
  - $not, $nin

<br>

### **범위**

- 다중 필드로 인덱스 설계 시
  - 완전 일치가 사용될 필드를 앞에 ({‘x’ : 1})
  - 범위 안에서 검색할 필드를 뒤에 (‘y’ : {‘gt’ : 3, ‘lt’ : 5})

<br>

### **OR 쿼리**

- 몽고 DB는 쿼리 당 하나의 인덱스만 사용 가능
- 유일한 예외는 ‘$or’
  - 예시) index: {‘x’: 1}, {‘y’:1}, query: {‘x’: 123, ‘y’:456}
  - 일반적인 쿼리의 경우 두 개의 인덱스 중 하나만 사용
- $or 은 두개의 쿼리 수행 후 중복을 제거하여 결과를 합침 (절마다 하나씩 인덱스를 사용 가능)
- 여러 번 쿼리 후 병합 시 비효율적이므로 $or 보다 가급적이면 $in을 사용할 것

<br>

### **서브 도큐먼트 (내장 도큐먼트) 인덱싱**

- 서브 도큐먼트의 필드를 인덱싱 하는 것과 내장 도큐먼트 자체를 인덱싱 하는 것은 작동 방식에 차이 존재
- 서브 도큐먼트의 필드 인덱싱
  - 해당 필드를 사용하는 쿼리 시 도움
- 서브 도큐먼트 자체를 인덱싱
  - 서브 도큐먼트 전체 쿼리 시에만 도움
- 예시) 도큐먼트: user: {‘username’ : “name”, “loc” : {“ip”: “0.0.0.0”, “city” : “Seoul”, “state” : “NY”}}
  - 인덱스: {“loc.city” : 1} 경우 loc.city 사용 쿼리에 사용
  - 인덱스: {“loc” : 1} 경우 도큐먼트 전체가 올바른 필드 순서로 기술된 쿼리에만 인덱스 사용

<br>

### **배열 인덱싱**

- 배열을 인덱싱하면 배열의 각 요소에 인덱스 항목을 생성
- 입력/갱신/제거 작업 시 모든 배열 요소가 갱신되어야 하므로 부담
- 배열의 특정 항목에 인덱스 생성 가능
  - ex) db.blog.createIndex({“comments.10.votes” : 1}). => 11번째 요소 찾을 때만 사용 (인덱스 시작: 0)
- 배열 전체를 단일 개체처럼 인덱싱 불가
- 배열 요소 인덱싱에는 위치 개념이 없어서 comment.4 처럼 특정 배열 요소 찾는 쿼리에 적용 불가
- 인덱스 항목의 한 필드만 배열로부터 가져올 수 있음
  - 다중 키 인덱스(Multi key Index)에 의해 n\*m개 인덱스가 생기는 것을 방지
  - 배열 필드를 인덱스 키로 가지면 인덱스는 즉시 다중키 인덱스로 표시 (explain에서 ‘isMultiKey’ 표현)
  - 다중키로 표현되면 도큐먼트가 모두 제거되어도 비다중키가 될 수 없음
    - 인덱스를 삭제 후 재생성 해야만 가능
    - 다중키는 비 다중키보다 약간 느림

<br>

### **인덱스 카디널리티**

- 카디널리티 : 컬렉션의 한 필드에 대해 고윳값이 얼마나 많은지 나타냄
  - 성별같은 필드는 값이 2개 뿐이며 매우 낮은 카디널리티
  - 이름, 이메일주소 등은 높은 카디널리티
- 카디널리티가 높을 수록 인덱싱에 도움이 되는 필드
- 복합 인덱스에서 카디널리티가 높은 키를 앞에 두는 것이 유리함

<br>

### **인덱스를 생성하지 않는 경우**

- 인덱스는 데이터의 일부를 조회할 때 가장 효율적, 컬렉션에서 가져와야 하는 부분이 많을수록 비효율적
- 인덱스를 하나 사용하기 위해 두번의 조회가 필요
  - 인덱스 항목 스캔, 인덱스 포인터가 가리키는 도큐먼트 스캔
- 따라서 인덱스가 없는게 더 빠른 쿼리도 존재
- 인덱스 사용보다 컬렉션 스캔이 적합한 경우 존재

| 인덱스가 적합 | 컬렉션 스캔이 적합 |
| :-----------: | :----------------: |
|   큰 컬렉션   |    작은 컬렉션     |
|  큰 도큐먼트  |   작은 도큐먼트    |
|  선택적 쿼리  |   비선택적 쿼리    |

<br>

- **선택 쿼리**: 단순히 데이터 검색만을 수행
- **실행 쿼리**: 테이블의 내용을 변경하는 쿼리

---

<br>

## **인덱스 종류**

### **고유 인덱스 (Unique Index)**

- 각 값이 인덱스에 한 번 이하 나타나도록 보장
- 특정 필드가 unique해야 한다는 제약조건 걸 때 사용
- 기존 컬렉션에 고유 인덱스 구축 시 중복값 있으면 실패
- `db.collection.createIndex({username: 1}, {unique: true})`

<br>

### **복합 고유 인덱스**

- 개별 키는 같은 값을 가질 수 있음
- 인덱스 항목의 모든 키에 걸친 값의 조합은 unique
- MongoDB에서 큰 파일을 저장하는 표준 방식

<br>

### **부분 인덱스**

- 부분 인덱스는 생성하려는 filter expression을 나타내는 도큐먼트와 sparse index가 제공하는 기능의 슈퍼셋
- 부분 인덱스를 만드려면 `partialFilterExpression` 옵션을 포함
- 고유한 필드가 존재하거나 필드가 아예 존재하지 않으면 `unique`, `partial`을 결합
- ex) `db.users.ensureIndex({'email' : 1}, {'unique' : true, 'partialFilterExpression' : {'email' : { '$exists': true}}})`
- 반드시 고유할 필요 없음
  - 고유하지 않은 부분 인덱스를 만드려면 `unique` 옵션을 제외
  - 고유 인덱스는 `null`을 값으로 취급하여 키가 없는 도큐먼트가 여러 개인 고유 인덱스 만들 수 없음

```sh
# collection에서 한 도큐먼트만 'x'를 갖지 않음
> db.foo.find()
{'_id' : 0}
{'_id' : 1, 'x' : 1}
{'_id' : 2, 'x' : 2}
{'_id' : 3, 'x' : 3}

# x에 쿼리 실행 시 모든 도큐먼트 반환
> db.foo.find({'x' : {'$ne' : f2}})
{'_id' : 0}
{'_id' : 1, 'x' : 1}
{'_id' : 2, 'x' : 2}
{'_id' : 3, 'x' : 3}

# 'x'에 부분 인덱스 생성 시 'x'가 없는 도큐먼트는 제외
# 만약 필드가 없는 도큐먼트 필요하면 hint를 사용하여 테이블 스캑을 하도록 강제
> db.foo.find({'x' : {'$ne' : f2}})
{'_id' : 1, 'x' : 1}
{'_id' : 2, 'x' : 2}
{'_id' : 3, 'x' : 3}
```

<br>

> **[Tip]**<br>
>
> - `partial` 속성: document의 조건을 정하여 일부 document에만 인덱스를 적용 할 때 사용<br>
> - 필요한 부분에만 인덱싱을 사용하여 저장공간 절약 및 속도 향상<br>
> - ex) visitors 값이 1000 보다 높은 document에만 name 필드에 인덱스 적용<br> > `db.[컬렉션명].createIndex( { name: 1 }, { partialFilterExpression: { visitors: { $gt: 1000 } } } )`

---

<br>

## **5.5 인덱스 관리**

- 인덱스는 컬렉션 당 한 번만 생성
- 동일한 인덱스 재생성 시 아무일도 일어나지 않음
- 인덱스 정보는 `system.indexes` 컬렉션에 저장
- 인덱스 정보 확인은 `db.collection.getIndexes()` 실행
  - **key** : 키는 힌트에 사용하거나 인덱스가 명시되야 하는 위치에 사용
  - **name** : 인덱스명으로 인덱스 작업에서 식별자로 사용
  - **v** : index versioning에 사용

<br>

### **인덱스 식별**

- 각 인덱스는 고유하게 식별하는 **인덱스명** 존재
- **인덱스명**으로 인덱스를 삭제, 조작하는데 사용
- 기본 인덱스명은 **키명1*방향1*...*키명N*인덱스명N** (방향: 1 or -1)
- `createIndex`의 **name** 옵션으로 원하는 이름 지정 가능
- `getLastError`로 인덱스 성공, 실패 여부를 알 수 있지만 **deprecated**된 기능

<br>

### **인덱스 변경**

- `dropIndex('<인덱스 명>')`으로 인덱스 제거
- Mongo DB 4.2 이후 **인덱스 구축 시 모든 읽기, 쓰기 작업 중단**
  - 인덱스 구축 시 많은 리소스가 필요하여 빠른 구축을 위함
  - 인덱스 구축 시에도 읽기, 쓰기 작업을 하려면 `background` 옵션을 사용
  - 단, 백그라운드 인덱싱은 포그라운드 인덱싱보다 훨씬 느림
- Mongo DB 4.2 에서는 **하이브리드 인덱스 구축**을 도입
  - 인덱스 구축 프로세스의 **시작과 끝에만 락**을 가짐
  - 나머지 부분에서는 읽기 및 쓰기 작업을 interleaving 함
  - 포그라운드/백그라운드 인덱싱을 모두 대체 가능
- 기존 도큐먼트에 인덱스를 생성하는 것이 인덱스 생성 후 도큐먼트 삽입보다 빠름
